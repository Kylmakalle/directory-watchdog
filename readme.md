
# Удаленный монитор содержимого каталога

```
Нужно написать решение, состоящее из двух приложений, как минимум с консольным интерфейсом - клиент и сервер. Суть решения - удаленный монитор содержимого каталога.
Серверу нужно каким-то образом скормить путь к каталогу - например, через ключ запуска или конфиг. Клиенту нужно скормить адрес сервера (или, желательно, message broker'а, об этом ниже).
Сервер следит за изменениями в заданном каталоге, и, если содержимое изменилось, оно должно быстро обновиться на клиенте.
В идеале хотелось бы увидеть решение с использованием amqp.
```
# Запуск

В `.env` настраивается путь на хост машине, который должен мониториться.
В `server/.env` настраивается путь к брокеру.

`docker-compose up` запустит два контейнера - RabbitMQ и сервер.

Для запуска клиента нужно установить зависимости из `client/requirements.txt` и запустить `python3 client.py`, или воспользоваться docker.

Подключение к брокеру настраивается в `client/.env`

```shell script
docker build . --tag client:latest
docker run --env-file .env --tty --network="host" client:latest
```

`--network="host"` критично при тестировании локального сервера, иначе докер контейнер не достучится до localhost.

# Реализация

## Общее
Сервер поддерживает подключение нескольких клиентов, поддерживая актуальную информацию на каждом.

Сервер и Клиент общаются маленькими json-сообщениями, сериализация происходит с помощью `ujson`, эта библиотека должна дать небольшой плюс к скорости. 

Для использования ujson в alpine докер-контейнере, приходится устанавливать туда gcc. Однако, контейнер всё-равно гораздо легче обычного `python:3.7.7` - примерно в 4 раза.

## Сервер
Сервер следит за файлами с помощью библиотеки `watchdog`, которая подписывается на системные вызовы.

К сожалению, в docker-контейнере нельзя отслеживать изменения директорий, которые были подключены через volumes. [Подробнее](https://github.com/gorakhargosh/watchdog/issues/283#issuecomment-61079649).

Поэтому используется polling observer.


Сервер принимает сообщение `"INIT"` из очереди, высылая полный список контента в директории. Это полезно при первом подключении или переподключении клиента.

Далее, при любых изменениях, сервер присылает сообщение вида `{'event': <event>, 'file': <file>'}`, где `event` - добавление, удаление или замена (файл перемещён), а `file` - файл или директория, с которой произошел ивент.

Чтобы обеспечить такую работу, приходится использовать два потока и подключения - на отправку и принятие сообщений. Думаю, этот механизм ещё можно оптимизировать. Т.к при отключении сервера, подключение консьюмера просто убивается (daemon thread).

## Клиент

Клиент при запуске отправляет сообщение `"INIT"`, чтобы получить полный список контента в директории.

Далее, на каждое изменение в директории, клиент получает сообщение, которое затем точечно обрабатывает - либо удаляет, либо добавляет в список.

## Нюансы
- Есть предположение, что для больших каталогов будет быстрее отправлять всё содержимое, вместо фильтрации локальных и внешних данных. Поиск по массиву может очень сильно замедлиться в больших директориях.

- Сообщение `"INIT"` рассылается на все подключенные клиенты вместо прямого ответа, так как выбран упрощеенный механизм `fanout`.  
Поэтому на клиенте приходится игнорировать это сообщение в некоторых случаях.
Это можно улучшить, поработав над прямым ответом от сервера (`reply-to`) и более тонкой настройкой `queue`/`exchange`.
